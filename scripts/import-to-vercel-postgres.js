/**
 * Import exported Supabase JSON data into Vercel Postgres (or any Postgres).
 * Reads a timestamped export folder and generates a single .sql file of INSERTs.
 * Run the generated SQL in your Vercel/Neon Postgres SQL editor.
 *
 * Usage:
 *   node scripts/import-to-vercel-postgres.js exports/2025-01-15T12-00-00
 *
 * Then run the generated file in your Postgres SQL editor:
 *   exports/2025-01-15T12-00-00/import-into-vercel.sql
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Tables we can import (same order as export; dependency order for FKs)
const TABLES = [
  'custom_objective_year_groups',
  'custom_objective_areas',
  'custom_objectives',
  'year_groups',
  'category_groups',
  'custom_categories',
  'activities',
  'activity_custom_objectives',
  'lessons',
  'lesson_plans',
  'eyfs_statements',
  'half_terms',
  'lesson_stacks',
  'activity_stacks',
  'subjects',
  'subject_categories',
  'activity_packs',
  'user_purchases'
];

function escapeSql(val) {
  if (val === null || val === undefined) return 'NULL';
  if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
  if (typeof val === 'number' && !Number.isNaN(val)) return String(val);
  if (typeof val === 'object') return "'" + escapeLiteral(JSON.stringify(val)) + "'::jsonb";
  return "'" + escapeLiteral(String(val)) + "'";
}

function escapeLiteral(str) {
  return String(str).replace(/'/g, "''").replace(/\\/g, '\\\\');
}

function toSqlValue(val) {
  if (val === null || val === undefined) return 'NULL';
  if (Array.isArray(val)) return "'" + escapeLiteral(JSON.stringify(val)) + "'::jsonb";
  if (typeof val === 'object' && val !== null) return "'" + escapeLiteral(JSON.stringify(val)) + "'::jsonb";
  if (typeof val === 'boolean') return val ? 'TRUE' : 'FALSE';
  if (typeof val === 'number') return Number.isNaN(val) ? 'NULL' : String(val);
  return "'" + escapeLiteral(String(val)) + "'";
}

function rowToInsert(table, row) {
  const cols = Object.keys(row).filter(k => row[k] !== undefined);
  const colList = cols.join(', ');
  const valueList = cols.map(c => toSqlValue(row[c])).join(', ');
  return `INSERT INTO ${table} (${colList}) VALUES (${valueList});`;
}

function main() {
  const exportDir = process.argv[2];
  if (!exportDir) {
    console.error('Usage: node scripts/import-to-vercel-postgres.js <export-folder>');
    console.error('Example: node scripts/import-to-vercel-postgres.js exports/2025-01-15T12-00-00');
    process.exit(1);
  }

  const absDir = path.isAbsolute(exportDir) ? exportDir : path.join(process.cwd(), exportDir);
  if (!fs.existsSync(absDir)) {
    console.error('Export folder not found:', absDir);
    process.exit(1);
  }

  const outPath = path.join(absDir, 'import-into-vercel.sql');
  const lines = [
    '-- Generated by import-to-vercel-postgres.js',
    '-- Run this file in your Vercel/Neon Postgres SQL editor.',
    '-- If you re-run, truncate tables first or run schema on an empty DB.',
    ''
  ];

  let totalRows = 0;
  for (const table of TABLES) {
    const jsonPath = path.join(absDir, table + '.json');
    if (!fs.existsSync(jsonPath)) {
      console.log('‚è≠Ô∏è  Skipping (no file):', table);
      continue;
    }
    const raw = fs.readFileSync(jsonPath, 'utf8');
    let rows;
    try {
      rows = JSON.parse(raw);
    } catch (e) {
      console.error('‚ùå Invalid JSON:', jsonPath, e.message);
      continue;
    }
    if (!Array.isArray(rows)) {
      console.log('‚è≠Ô∏è  Skipping (not array):', table);
      continue;
    }
    for (const row of rows) {
      lines.push(rowToInsert(table, row));
      totalRows++;
    }
    console.log('‚úÖ', table + ':', rows.length, 'rows');
  }

  fs.writeFileSync(outPath, lines.join('\n'));
  console.log('\nüìÑ Written:', outPath);
  console.log('üìä Total INSERTs:', totalRows);
  console.log('\nüí° Next: Open your Vercel/Neon Postgres SQL editor and run the contents of:', outPath);
}

main();
